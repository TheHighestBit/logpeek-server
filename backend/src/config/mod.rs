use std::fs::File;
use std::io::Write;
use config::Config;
use once_cell::sync::Lazy;

pub const fn config_setup() -> Lazy<Config> {
    Lazy::new(|| {
        let args: Vec<String> = std::env::args().collect();

        let path = if args.len() > 1 {
            args[1].clone()
        } else {
            "config.toml".to_string()
        };
        
        if let Ok(md) = std::fs::metadata(&path) {
            if !md.is_file() {
                panic!("Config path is not a file! If you are trying to generate a new file, make sure to specify the desired path to the file, not to the directory.");
            }
        }

        if let Ok(mut file) = File::create_new(&path) {
            // Logger is not initialized yet, so we can't use log macros
            println!("No config file found, creating default config {}", path);

            file.write_all(DEFAULT_CONFIG.as_bytes()).expect("Failed to write default config");
        }

        Config::builder()
            .add_source(config::File::with_name(&path).required(false))
            .add_source(config::Environment::with_prefix("LOGPEEK").separator("_"))
            .build()
            .expect("There is an issue with the configuration file")
    })
}

const DEFAULT_CONFIG: &str = r#"# Config file for logpeek-server. Place this file in the same directory as the server executable.
# The values in this example config are the defaults.

# General configuration options.
[main]

# Host address of the server
address = "127.0.0.1:3001"

# The password used for authentication. Omitting this will disable authentication.
#secret = "replace_me"

# The maximum number of login attempts before the server is locked. Cleared by manual server restart.
max_login_attempts = 3

# Minimum amount of time between log buffer updates. Triggered by ANY request to the server.
# Force-refresh button in the frontend bypasses this.
buffer_update_cooldown = 10


[main.logger]
# When true, sets the minimum log level to debug
enable_debug = false

# Whether to write log files
log_to_file = true

# When log_to_file is true, logs will be written to this directory
log_path = "logpeek-logs"


# List of applications whose log files will be monitored. Each application must have a path, a respective parser, the timeformat and optional buffer_size.
[[application]]
# Path to the application's log folder or a single logfile. The path can be relative to the server executable or an absolute path. Nested subfolders are supported.
# Make sure that this path is both accessible and does not contain any other files besides log files. The file extension doesn't matter.
path = "logpeek-logs"

# The regular expression used to parse the logs files of this application.
# All 4 possible named capture groups are present in the example below. Only the message capture group is required.
parser = '''^(?P<timestamp>\S+) (?P<level>\S+) (?P<module>\S+) - (?P<message>.+)$''' # This example corresponds to the logs generated by logpeek-server itself
#parser = '''^(?P<message>.+)$''' # This is the minimal example, use this if you don't care about filtering by other fields.

# The format of the timestamp in the logs. Supported formats are "iso8601", "rfc3339", "rfc2822" and custom.
# Altough custom timeformats are supported, built-in formats should be preferred.
# Since UTC is used internally, the timeformat must include an offset. Minimum example for a custom timeformat: "[year]-[month]-[day]|[hour]|[offset_hour]"
# Refer to https://time-rs.github.io/book/api/format-description.html (version 1) for possible options.
timeformat = "iso8601"

# The size of the log buffer that is kept in memory. When the buffer is full, the oldest logs are discarded first.
buffer_size = 1_000_000

# There is no limit to the amount of applications that can be monitored at once.
# Simply add another [[application]] section with the same fields as above.
"#;